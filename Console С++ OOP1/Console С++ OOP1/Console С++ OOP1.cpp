#include <iostream>
using namespace std;

//// вузол списка (або один елемент)
//class Node {
//public:
//    int value;
//    // додається конструктор, задля того, щоб під час створення елемента ОДРАЗУ записати в нього значення
//    Node(int value) {
//        this->value = value;
//    }
//};
//
//int main()
//{
//    // можна звісно спробувати зробити елемент і на стеке, але це погана ідея (стек маленький - 1 МБ)
//    // Node element;
//
//    // тому пам'ять виділяється в рантаймі (в купі) через оператор нью, а він поверне адресу
//    Node* ptr = new Node(1);
//    // ptr->value = 1; // щоб не робити окремий запис в поле, тепер в класі є конструктор
//    // cout << ptr->value << "\n"; // 1
//}

// ---------------------------------------------------------------
 //вузол списка (або один елемент)
//class Node {
//public:
//    int value; //корисні дані (userful data)
//	Node* next; // адреса наступного вузла списку
//
//    // додається конструктор, задля того, щоб під час створення елемента ОДРАЗУ записати в нього значення
//    Node(int value) {
//        this->value = value;
//		this->next = nullptr; // наступного елемента списку ще немає
//    }
//};
//
//int main()
//{
//    Node* a = new Node(1);
//    Node* b = new Node(2); // створюється черговий, другий, наступний елемент списку
//    // оператор нью поверне адресу нового другого елемента списку (ы вона буде зберыгатися в покажчику)
//    a->next = b; // адресу другого елемента повыдомляємо першому елементу списка
//
//    Node* c = new Node(3);
//    b->next = c;
//
//    Node* d = new Node(4);
//    c->next = d;
//
//	cout << a << "\n"; // адреса першого елемента списку
//	cout << a->value << "\n"; // 1
//	cout << a->next << "\n"; // адреса другого елемента списку
//	cout << a->next->value << "\n"; // 2
//	cout << a->next->next << "\n"; // адреса третього елемента списку
//	cout << a->next->next->value << "\n"; // 3
//	cout << a->next->next->next << "\n"; // адреса четвертого елемента списку
//	cout << a->next->next->next->value << "\n"; // 4
//}

// ---------------------------------------------------------------

//class Node {
//public:
//    int value; //корисні дані (userful data)
//    Node* next; // адреса наступного вузла списку
//
//    // додається конструктор, задля того, щоб під час створення елемента ОДРАЗУ записати в нього значення
//    Node(int value) {
//        this->value = value;
//        this->next = nullptr; // наступного елемента списку ще немає
//    }
//};
//
//int main()
//{
//	// голова списку (адреса першого елемента списку)
//	Node* head = nullptr; // спочатку список порожній
//
//	// створюється перший елемент списку і голова списку вказує на нього
//    head = new Node(1);
//
//	// створюється другий елемент списку і зв'язується з головою
//    head->next = new Node(2);
//	// створюється третій елемент списку і зв'язується з другим
//	head->next->next = new Node(3);
//	head->next->next->next = new Node(4);
//
//    cout << head << "\n"; // адреса першого елемента списку
//    cout << head->value << "\n"; // 1
//    cout << head->next << "\n"; // адреса другого елемента списку
//    cout << head->next->value << "\n"; // 2
//    cout << head->next->next << "\n"; // адреса третього елемента списку
//    cout << head->next->next->value << "\n"; // 3
//    cout << head->next->next->next << "\n"; // адреса четвертого елемента списку
//    cout << head->next->next->next->value << "\n"; // 4
//}

// ---------------------------------------------------------------

//class Node {
//public:
//    int value; //корисні дані (userful data)
//    Node* next; // адреса наступного вузла списку
//
//    // додається конструктор, задля того, щоб під час створення елемента ОДРАЗУ записати в нього значення
//    Node(int value) {
//        this->value = value;
//        this->next = nullptr; // наступного елемента списку ще немає
//    }
//};
//
//int main()
//{
//	// список пустий, елементів ще немає
//	Node* head = nullptr; // спочатку список порожній
//	Node* tail = nullptr; // спочатку список порожній
//
//    Node* current = new Node(1); 
//	head = current; // голова списку вказує на перший елемент
//    tail = current; // хвіст списку вказує на перший елемент (поки що він же і є останнім)
//	
//    current = new Node(2); 
//	tail->next = current; // зв'язується з попереднім останнім елементом
//	tail = current; // хвіст списку вказує на новий останній елемент
//
//    current = new Node(3);
//    tail->next = current;
//    tail = current; 
//
//    current = new Node(4);
//    tail->next = current;
//    tail = current;
//}