#include <iostream> 
using namespace std;

class SinglyLinkedList // визначення класу для однозв’язного списку
{
public:
    struct Node // визначення структури вузла списку
    {
        int data = 0; // зберігання даних у вузлі
        Node* next = nullptr; // вказівник на наступний вузол
    };

private:
    Node* head = nullptr; // вказівник на початок списку
    Node* tail = nullptr; // вказівник на кінець списку
    int count = 0; // лічильник кількості вузлів у списку

public:
    void AddToHead(int data) // метод для додавання вузла в початок списку
    {
        Node* newElem = new Node(); // створення нового вузла
        newElem->data = data; // присвоєння даних новому вузлу
        newElem->next = head; // зв’язування нового вузла з поточною головою
        if (head == nullptr) // перевірка, чи список порожній
        {
            tail = newElem; // встановлення хвоста, якщо список був порожнім
        }
        head = newElem; // оновлення голови списку
        count++; // збільшення лічильника вузлів
    }

    void AddToTail(int data) // метод для додавання вузла в кінець списку
    {
        Node* newElem = new Node(); // створення нового вузла
        newElem->data = data; // присвоєння даних новому вузлу
        if (tail == nullptr) // перевірка, чи список порожній
        {
            head = newElem; // встановлення голови, якщо список був порожнім
        }
        else
        {
            tail->next = newElem; // зв’язування поточного хвоста з новим вузлом
        }
        tail = newElem; // оновлення хвоста списку
        count++; // збільшення лічильника вузлів
    }

    void InsertInto(int data, int position) // метод для вставки вузла на задану позицію
    {
        if (position >= count) // перевірка, чи позиція виходить за межі списку
        {
            AddToTail(data); // додавання в кінець, якщо позиція за межами
            return; // завершення функції
        }
        else if (position <= 0) // перевірка, чи позиція на початку або до нього
        {
            AddToHead(data); // додавання в початок, якщо позиція недійсна
            return; // завершення функції
        }

        Node* newElem = new Node(); // створення нового вузла
        newElem->data = data; // присвоєння даних новому вузлу
        int i = 1; // ініціалізація лічильника для проходження списку
        Node* beforeNew = head; // вказівник на вузол перед місцем вставки
        while (i++ != position) // проходження до потрібної позиції
        {
            beforeNew = beforeNew->next; // перехід до наступного вузла
        }
        newElem->next = beforeNew->next; // зв’язування нового вузла з наступним
        beforeNew->next = newElem; // вставка нового вузла в список
        count++; // збільшення лічильника вузлів
    }

    void DeleteFromHead() // метод для видалення вузла з початку списку
    {
        if (count == 0) // перевірка, чи список порожній
        {
            // cout << "Empty list!\n";
            return; // завершення функції, якщо список порожній
        }
        Node* temp = head; // збереження вказівника на голову для видалення
        head = head->next; // оновлення голови списку
        delete temp; // звільнення пам’яті видаленого вузла
        count--; // зменшення лічильника вузлів
        if (head == nullptr) // перевірка, чи список став порожнім
        {
            tail = nullptr; // очищення хвоста, якщо список порожній
        }
    }

    void DeleteFromTail() // метод для видалення вузла з кінця списку
    {
        if (count == 0) { // перевірка, чи список порожній
            // cout << "Empty list!\n";
            return; // завершення функції, якщо список порожній
        }
        DeleteByIndex(count - 1); // виклик видалення за індексом для останнього вузла
    }

    void DeleteByIndex(int position) // метод для видалення вузла за заданою позицією
    {
        if (position <= 0) // перевірка, чи позиція на початку або до нього
        {
            DeleteFromHead(); // видалення з початку, якщо позиція недійсна
            return; // завершення функції
        }

        if (position >= count) // перевірка, чи позиція виходить за межі списку
        {
            position = count - 1; // корекція позиції до останнього вузла
        }

        int i = 1; // ініціалізація лічильника для проходження списку
        Node* beforeDel = head; // вказівник на вузол перед видаленням
        while (i++ != position) // проходження до потрібної позиції
        {
            beforeDel = beforeDel->next; // перехід до наступного вузла
        }
        Node* sacrifice = beforeDel->next; // збереження вказівника на вузол для видалення
        beforeDel->next = sacrifice->next; // перев’язування списку, обходячи видалений вузол
        delete sacrifice; // звільнення пам’яті видаленого вузла
        count--; // зменшення лічильника вузлів
        if (beforeDel->next == nullptr) // перевірка, чи видалений вузол був останнім
        {
            tail = beforeDel; // оновлення хвоста списку
        }
    }

    void Clear() // метод для очищення всього списку
    {
        while (head != nullptr) // цикл для видалення всіх вузлів
        {
            DeleteFromHead(); // видалення вузла з початку
        }
    }

    void Print() const // метод для виведення списку
    {
        if (count == 0) // перевірка, чи список порожній
        {
            cout << "Empty list!\n"; // виведення повідомлення про порожній список
            return; // завершення функції
        }
        Node* current = head; // ініціалізація вказівника для проходження списку
        while (current != nullptr) // цикл для проходження всіх вузлів
        {
            cout << current->data << " "; // виведення даних поточного вузла
            current = current->next; // перехід до наступного вузла
        }
        cout << endl; // додавання нового рядка після виведення
    }

    int GetCount() const // метод для отримання кількості вузлів
    {
        return count; // повернення значення лічильника
    }

    int IndexOf(int data) const // метод для пошуку індексу вузла за значенням
    {
        if (count == 0) // перевірка, чи список порожній
        {
            // cout << "Empty list!\n";
            return -1; // повернення -1, якщо список порожній
        }
        Node* temp = head; // ініціалізація вказівника для проходження списку
        int i = 0; // ініціалізація лічильника позицій
        while (i < count) // цикл для проходження всіх вузлів
        {
            if (data == temp->data) // перевірка збігу даних у вузлі
            {
                return i; // повернення індексу знайденого вузла
            }
            i++; // збільшення лічильника позицій
            temp = temp->next; // перехід до наступного вузла
        }
        return -1; // повернення -1, якщо значення не знайдено
    }
};

int main()
{
    SinglyLinkedList sll; // створення об’єкта однозв’язного списку

    // вставка в кінець списку
    sll.AddToTail(10); // додавання значення 10 в кінець
    sll.AddToTail(20); // додавання значення 20 в кінець
    sll.AddToTail(30); // додавання значення 30 в кінець
    sll.AddToTail(40); // додавання значення 40 в кінець
    sll.Print(); // виведення списку після додавання

    // вставка в початок списку
    sll.AddToHead(50); // додавання значення 50 на початок
    sll.AddToHead(60); // додавання значення 60 на початок
    sll.AddToHead(70); // додавання значення 70 на початок
    sll.AddToHead(80); // додавання значення 80 на початок
    sll.Print(); // виведення списку після додавання

    // кількість елементів та пошук
    cout << "count: " << sll.GetCount() << "\n"; // виведення кількості елементів у списку
    cout << "index of 70: " << sll.IndexOf(70) << ", index of 90: " << sll.IndexOf(90) << "\n"; // виведення індексу значення 70 та 90

    // вставка в середину
    sll.InsertInto(-1, -1); // вставка значення -1 на недійсну позицію
    sll.Print(); // виведення списку після вставки
    sll.InsertInto(2, 2); // вставка значення 2 на позицію 2
    sll.Print(); // виведення списку після вставки
    sll.InsertInto(22, 22); // вставка значення 22 за межі списку
    sll.Print(); // виведення списку після вставки

    // видалення з початку списку
    sll.DeleteFromHead(); // видалення першого вузла
    sll.DeleteFromHead(); // видалення другого вузла
    sll.DeleteFromHead(); // видалення третього вузла
    sll.Print(); // виведення списку після видалення

    // видалення з кінця списку
    sll.DeleteFromTail(); // видалення останнього вузла
    sll.DeleteFromTail(); // видалення передостаннього вузла
    sll.DeleteFromTail(); // видалення ще одного вузла з кінця
    sll.Print(); // виведення списку після видалення

    // видалення по вказаному індексу
    sll.DeleteByIndex(0); // видалення вузла за індексом 0
    sll.DeleteByIndex(1); // видалення вузла за індексом 1
    sll.DeleteByIndex(2); // видалення вузла за індексом 2
    sll.Print(); // виведення списку після видалення

    // очищення списку
    sll.Clear(); // видалення всіх вузлів зі списку
    sll.Print(); // виведення списку після очищення
}