#include <iostream>
using namespace std;

// структура - це користувацький композитний ТИП ДАНИХ
// тип даних = множина допустимих значень + множина операцій

// множина операцій для інта - це плюс мінус помножити і тд
// множина операцій для контакту - це створення, редагування, видалення, перегляд, виклик, відхилення і тд
// так як нема окремого значка для операцій щодо контактів, то всі ці дії будуть описані функціями!

//// проблема:
//// 1) множина значень не захищена певними правилами
//// 2) множина операцій НЕ Є ЧАСТИНОЮ ТИПУ !!! всі функції десь окремо !!!
//struct Contact {
//	// список полів структури (характеристик, атрибутів)
//	// відповідає лише на питання "ЩО ВОНО ТАКЕ?"
//	// відповідь ЛИШЕ на це питання не дає розуміння, як вцілому має бути описана та чи інша сутність
//	// множина допустимих значень:
//	// сказано, що є 4 частини, при чому іменовані
//	// для кожної частини присутня інформація про доступний діапазон значень
//	string name; // будь який рядок від "" до будь якої довжини
//	string lastname;
//	string* phone_numbers; // покажчик - тримає в собі адресу
//	string picture;
//	int age; // ПРОБЛЕМА1: якщо поле з типом інт, то у поле ВІК можна записати будь яке значення від -2млрд до +2млрд
//	// як вік може бути від'ємним???
//	// в програміста-користувача цього типу буде можливість записати якесь неправильне значення в поле, скажімо -5, А ЦЕ ПРЯМИЙ ШЛЯХ ДО БАГІВ!!!!!!
//	// можна дописати перед інтом - unsigned
//	// але тоді діапазон буде від 0 .... але до 4млрд....
//	// можна змінити тип з інта на ансайнед шорт - 0...65535
//};

//// навіть з точки зору множини допустимих значень, у структури є проблема з валідацією даних, які користувач захоче записати у змінну структурного типу
//// наприклад, в імені не може бути таких символів як !@#$%^&*()
//// вік має діапазон від 0 до 150 років
//void Dial(const Contact& contact) {
//	// cout << contact.
//}

//// можливе рішення:
//// зробити окрему глобальну функцію для встановлення правильних значень
//void SetAge(Contact& contact, int new_age) {
//	if (new_age >= 0 && new_age <= 150) {
//		contact.age = new_age;
//		cout << "OK!";
//	}
//	else {
//		// cout << "OOPS! Error age!\n";
//		// throw "ERROR";
//		contact.age = 18;
//	}
//}

//int main() {
//	Contact c1;
//	c1.name = "Alex";
//	// викликаємо функцію для встановлення віку
//	SetAge(c1, 12); // логіка по перевірці валідності значення
//	cin >> c1.age; // наявність окремої функції не вирішує проблему захисту значеннь повінстю, тому що в користувача ВСЕ ОДНО ЗАЛИШАЄТЬСЯ доступ до полів напряму
//	cout << c1.age << "\n";
//}

//---------------------------------------------------------------------

//class Contact {
//public:
//	// МНОЖИНА ЗНАЧЕНЬ
//	// поля (характеристики, атрібути) - РЕАЛІЗАЦІЯ (ЩО ВОНО ТАКЕ)
//	string name; // будь який рядок від "" до будь якої довжини
//	string lastname;
//	string* phone_numbers; // покажчик - тримає в собі адресу
//	string picture;
//	int age;
//
//	// МНОЖИНА ОПЕРАЦІЙ
//	// методи (функції класу) - ІНТЕРФЕЙС (ЩО ВОНО ВМІЄ РОБИТИ? ЯК ЦЯ СУТНІСТЬ ВМІЄ ВЗАЄМОДІЯТИ З ІНШИМИ СУТНОСТЯМИ)
//	void Dial(const Contact& contact) {
//		// cout << contact.
//	}
//
//	void Create() {
//		cout << "contact was created\n";
//	}
//
//	void Show() {
//		cout << "contact SHOW\n";
//	}
//
//	void Edit() {
//		cout << "contact EDIT\n";
//	}
//
//	void Delete() {
//		cout << "contact DELETE\n";
//	}
//};
//
//int main() {
//	Contact c1;
//	// c1.
//
//}

//---------------------------------------------------------------------

//class Person {
//public:
//	string name;
//	int age;
//	int happiness = 50; // 0...100
//
//	// methods
//};
//
//class Cat {
//public:
//	// СТАН (РЕАЛІЗАЦІЯ, состояние) - характеристики
//	string nick;
//	int paws = 4;
//	int energy = 100; // 0...100
//
//	// ПОВЕДІНКА (ІНТЕРФЕЙС)
//	void Play(Person& person) {
//		cout << nick << " plays with " << person.name << "\n";
//		person.happiness++; // в результаті взаємодії стани одного чи обох об'єктів можуть змінюватися		energy--;
//		energy -= 10;
//	}
//};
//
//class Contact {
//public:
//	// МНОЖИНА ЗНАЧЕНЬ
//	// поля (характеристики, атрібути) - РЕАЛІЗАЦІЯ (ЩО ВОНО ТАКЕ)
//	string name; // будь який рядок від "" до будь якої довжини
//	string lastname;
//	string* phone_numbers; // покажчик - тримає в собі адресу
//	string picture;
//	int age;
//
//	// МНОЖИНА ОПЕРАЦІЙ
//	// методи (функції класу) - ІНТЕРФЕЙС (ЩО ВОНО ВМІЄ РОБИТИ? ЯК ЦЯ СУТНІСТЬ ВМІЄ ВЗАЄМОДІЯТИ З ІНШИМИ СУТНОСТЯМИ)
//	void Dial(const Contact& contact) {
//		// cout << contact.
//	}
//
//	void Create() {
//		cout << "contact was created\n";
//	}
//
//	void Show() {
//		cout << "contact SHOW\n";
//	}
//
//	void Edit() {
//		cout << "contact EDIT\n";
//	}
//
//	void Delete() {
//		cout << "contact DELETE\n";
//	}
//};
//
//int main() {
//	// Програма складається з об'єктів,
//	// що обмінюються повідомленнями. 
//	Person person; // перший об'єкт
//	person.name = "Alex"; // налаштування стану
//
//	Cat cat; // другий об'єкт (змінна класового типу)
//	cat.nick = "Barsik";
//	cat.Play(person); // ВЗАЄМОДІЯ (котик відпрявляє повідомлення людині)
//
//	cout << person.happiness << "\n";
//	cout << cat.energy << "\n";
//
//	cat.Play(person); // ВЗАЄМОДІЯ (котик відпрявляє повідомлення людині)
//
//	cout << person.happiness << "\n";
//	cout << cat.energy << "\n";
//}

//---------------------------------------------------------------------


//int main() {
//
//	Person person1;
//
//	person1.name = "Alex";
//
//	Person person2;
//
//	person2.name = "Maria";
//
//	cout << person1.name << "\n";
//
//	cout << person2.name << "\n";
//
//	cout << &person1.name << "\n";
//
//	cout << &person2.name << "\n";
//
//	// в кожного об'єкта СВОЇ ВЛАСНІ ПОЛЯ!
//
//}
//// в кожного об'єкта СВОЇ ВЛАСНІ ПОЛЯ!
//// методи не копіюються на кожний об'єкт при його створенні, інтерфейс ЗАГАЛЬНИЙ
//// буде одна функція Плей на всіх котиків!
//// функція важка, займає багато місця в пам'яті

//---------------------------------------------------------------------

//class Person {
//public:
//	string name;
//	int age;
//	int happiness = 50; // 0...100
//
//	// methods
//};
//
//class Cat {
//public:
//	// СТАН (РЕАЛІЗАЦІЯ, состояние) - характеристики
//	string nick;
//	int paws = 4;
//	int energy = 100; // 0...100
//
//	// ПОВЕДІНКА (ІНТЕРФЕЙС)
//	void Play(Person& person) {
//		if (paws == 0) {
//			cout << nick << " cannot play with " << person.name << "\n";
//			return;
//		}
//		cout << nick << " plays with " << person.name << "\n";
//		person.happiness++; // в результаті взаємодії стани одного чи обох об'єктів можуть змінюватися		energy--;
//		energy -= 10;
//	}
//};
//
//class Contact {
//public:
//	// МНОЖИНА ЗНАЧЕНЬ
//	// поля (характеристики, атрібути) - РЕАЛІЗАЦІЯ (ЩО ВОНО ТАКЕ)
//	string name; // будь який рядок від "" до будь якої довжини
//	string lastname;
//	string* phone_numbers; // покажчик - тримає в собі адресу
//	string picture;
//	int age;
//
//	// МНОЖИНА ОПЕРАЦІЙ
//	// методи (функції класу) - ІНТЕРФЕЙС (ЩО ВОНО ВМІЄ РОБИТИ? ЯК ЦЯ СУТНІСТЬ ВМІЄ ВЗАЄМОДІЯТИ З ІНШИМИ СУТНОСТЯМИ)
//	void Dial(const Contact& contact) {
//		// cout << contact.
//	}
//
//	void Create() {
//		cout << "contact was created\n";
//	}
//
//	void Show() {
//		cout << "contact SHOW\n";
//	}
//
//	void Edit() {
//		cout << "contact EDIT\n";
//	}
//
//	void Delete() {
//		cout << "contact DELETE\n";
//	}
//};
//
//int main() {
//	Person p;
//	p.name = "Alex";
//
//	Cat c;
//	c.nick = "Barsik";
//	c.paws = 0;
//	c.Play(p);
//}

//---------------------------------------------------------------------

class Person {
private: // класс закрив доступ до полів, і всього що знаходиться нижче
	// приклад правил 
	string name = ""; // !@#$%^&*()_ недопустимо
	int age = 0; // 0-150
	int happiness = 50; // 0-100
public:
	// приклад сеттеру (встановлювача)
	// це функція яка дозволить записати значення поля але згідно певних правил
	void SetAge(int new_age) {
		if (new_age < 0 || new_age > 150) {
			cout << "Incorrect value for age, Please enter value from 0 to 150.\n"; // просто повідомляємо користувача про помилку
			//age = 18; // встановлюємо значення за замовчуванням
		}
		else {
			age = new_age; // встановлюємо нове значення
			cout << "OK! Age set to " << age << "\n";
		}
	}
	void SetHappiness(int new_happiness) {
		if (new_happiness < 0 || new_happiness > 100) {
			cout << "Incorrect value for happiness, Please enter value from 0 to 100.\n"; // просто повідомляємо користувача про помилку
			//happiness = 50; // встановлюємо значення за замовчуванням
		}
		else {
			happiness = new_happiness; // встановлюємо нове значення
			cout << "OK! Happiness set to " << happiness << "\n";
		}
	}

	// приклад метода-геттера (отримувача)
	// тип такий же, як  поля
	// нзва бажано щоб починилася з гет
	// параметрів не буде
	// повертає значення поля
	// метод-геттер для отримання віку

	int GetAge() { 
		return age; // повертаємо значення віку
	}

	int GetHappiness() {
		return happiness; // повертаємо значення щастя
	}
};

int main() {
	Person p;

	//p.age = 235; // 0 - 15
	p.SetAge(234); // викликаємо функцію для встановлення віку, яка перевіряє значення на валідність
	p.SetHappiness(120); // викликаємо функцію для встановлення щастя, яка перевіряє значення на валідність
	// cout << p.age << "\n";
	cout << "Age: " << p.GetAge() << "\n"; // викликаємо функцію для отримання віку, яка повертає значення поля age
	cout << "Happiness: " << p.GetHappiness() << "\n"; // викликаємо функцію для отримання щастя, яка повертає значення поля happiness
};

//---------------------------------------------------------------------