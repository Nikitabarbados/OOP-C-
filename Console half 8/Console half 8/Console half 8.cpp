#include <iostream>
#include <windows.h>
#include <algorithm>
using namespace std;

// написати корисний, зрозумілий тип для роботи з динамічним масивом (поки що з елементами типу інт)

//class Array {
//	int* data; // покажчик на майбутній динамічний масив
//	unsigned int length;
//
//public:
//	Array() {
//		data = nullptr;
//		length = 0;
//		cout << "Створено пустий масив\n";
//	}
//
//	Array(int ar[], unsigned int size) {
//		if (size > 1000000) throw "error!\n";
//
//		// якщо в класі є поле-покажчик, то іноді прямо в конструкторі треба буде ВИДІЛЯТИ ПАМ'ЯТЬ динамічно під цей покажчик
//		length = size;
//		data = new int[length];
//		for (int i = 0; i < length; i++) {
//			data[i] = ar[i];
//		}
//		cout << "Створено непустий масив на " << size << " елементів\n";
//	}
//
//	// конструктор - метод, в який ми потрапляємо пілся створення об'єкта (записуємо значення в поля, виділяємо пам'ять під поля-покажчики)
//	// деструктор - метод, який викликається АВТОМАТИЧНО безпсередньо перед тим, як об'єкт буде знищено.
//	// 1) там можна зробити роздруківку і переконатися що об'єкт перестане існувати
//	// 2) пам'ять виділена під поля-покажчики може бути вівільнена САМЕ ТАМ
//
//	void Print() const {
//		if (length == 0) {
//			cout << "Масив пустий, нема чого показувати :(\n";
//		}
//		else {
//			cout << "Елементи масиву: ";
//			for (int i = 0; i < length; i++)
//			{
//				cout << data[i];
//				cout << (i == length - 1 ? "." : ", ");
//			}
//			cout << "\n";
//		}
//	}
//
//	unsigned int GetLength() const {
//		return length;
//	}
//
//	void AddToBack(int value) {
//		// робимо новий масив, в якому буде на 1 елемент більше
//		int* temp = new int[length + 1];
//		// переганяємо елементи зі старого масиву в новий
//		for (int i = 0; i < length; i++)
//		{
//			temp[i] = data[i];
//		}
//		// в кінець нового масиву додаємо передане значення через параметр
//		temp[length] = value;
//		// старий масив треба почистити, інакше буде виток пам'яті
//		delete[] data;
//		// переставляємо основний покажчик зі старого масива (якого доречі уже і не існує), на новий масив
//		data = temp;
//		// так як відбулося додавання 1 елемента в кінець масиву, то його довжина стала +1 
//		length++;
//	}
//
//	void RemoveFromBack() {
//		if (length == 0) {
//			cout << "Нема чого видаляти, масив жеж пустий!\n";
//			return; // якщо нема чого видаляти, то просто нічого не робимо
//			// throw "Помилка! Елементів нема!";
//		}
//		length--;
//		int* temp = new int[length];
//		for (int i = 0; i < length; i++)
//			temp[i] = data[i];
//		delete[] data;
//		data = temp;
//	}
//
//	void AddToFront(int value) {
//		// робимо новий масив, в якому буде на 1 елемент більше
//		int* temp = new int[length + 1];
//		// переганяємо елементи зі старого масиву в новий
//		for (int i = 0; i < length; i++)
//		{
//			temp[i + 1] = data[i];
//		}
//		// на початок нового масиву додаємо передане значення через параметр
//		temp[0] = value;
//		// старий масив треба почистити, інакше буде виток пам'яті
//		delete[] data;
//		// переставляємо основний покажчик зі старого масива (якого доречі уже і не існує), на новий масив
//		data = temp;
//		// так як відбулося додавання 1 елемента в кінець масиву, то його довжина стала +1 
//		length++;
//	}
//
//	void RemoveFromFront() {
//		if (length == 0) {
//			cout << "Нема чого видаляти, масив жеж пустий!\n";
//			return; // якщо нема чого видаляти, то просто нічого не робимо
//			// throw "Помилка! Елементів нема!";
//		}
//		length--;
//		int* temp = new int[length];
//		for (int i = 1; i < length + 1; i++)
//			temp[i - 1] = data[i];
//		delete[] data;
//		data = temp;
//	}
//
//	void SortAZ() {
//		sort(data, data + length);
//	}
//
//	void Shuffle() {
//		for (int i = 0; i < 10000; i++)
//		{
//			int ri1 = rand() % length;
//			int ri2 = rand() % length;
//			swap(data[ri1], data[ri2]);
//		}
//	}
//
//	void Add10RandomNumbers() {
//		for (int i = 0; i < 10; i++)
//			AddToBack(rand() % 100);
//	}
//
//	// приклад деструктора
//	// деструктор не можна перевантажити, він ніколи не приймає параметрів!
//	~Array() {
//		if (data != nullptr) {
//			delete[] data;
//		}
//		cout << "Об'єкт було знищено, а пам'ять - вивільнено!\n";
//	}
//
//	// конструктор копіювання
//	// 
//	Array(Array& original) {
//		this->length = original.length;
//		this->data = new int[this->length];
//		for (int i = 0; i < this->length; i++)
//		{
//			this->data[i] = original.data[i];
//		}
//	}
//};
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	Array original;
//	original.Add10RandomNumbers();
//	original.Print();
//
//	Array copy = original;
//	// Array copy(original); // виклик конструктору копіювання! КК
//	copy.Print();
//}

// ---------------------------------------------------------------------------
// 
// КК
// статік
// вектор
class Array {
	int* data = nullptr;
	unsigned int length = 0;
public:
	Array() {
		cout << "C-TOR WITHOUT PARAMETERS\n";
	}
	void AddToBack(int value) {
		int* temp = new int[length + 1];
		for (int i = 0; i < length; i++) temp[i] = data[i];
		temp[length] = value;
		delete[] data;
		data = temp;
		length++;
	}

	void AddToFront(int value) {
		int* temp = new int[length + 1];
		for (int i = 0; i < length; i++) temp[i + 1] = data[i];
		temp[0] = value;
		delete[] data;
		data = temp;
		length++;
	}

	void RemoveFromBack() {
		if (length == 0) {
			cout << "масив пустий, видаляти НЕМА ЧОГО!\n";
			return;
		}
		int* temp = new int[length - 1];
		for (int i = 0; i < length - 1; i++)
		{
			temp[i] = data[i];
		}
		delete[] data;
		data = temp;
		length--;
	}

	// RemoveFromFront
	// Insert
	// RemoveByIndex(4);
	// RemoveByValue(10);
	// Sort();
	// Reverse();
	// Shuffle();

	void Print() const {
		if (length == 0) {
			cout << "масив пустий!\n";
		}
		else {
			cout << "елементи масиву: ";
			for (int i = 0; i < length; i++)
			{
				cout << data[i] << " ";
			}
			cout << "\n";
		}
	}
	~Array() {
		cout << "D-TOR\n";
		if (data != nullptr) {
			delete[] data;
		}
	}

	// задача по створенню об'єктів будь якого типу на основі іншого вже існуючого об'єкта такого ж типу - зустрічається майже постійно
	// і в процедурці, і в ООП постійно йде робота з функціями (або методами)
	// часто у функції передаються параметри (але не завжди ЗА ПОКАЖЧИКОМ, або ЗА ПОСИЛАННЯМ)
	// і зазвичай саме ЗА ЗНАЧЕННЯМ (тобто створюється копія об'єкта)
	// об'єкти потребують копіювання дуже часто - при передачі аргументів у функцію або при поверненні значень з функції
	// в кожному класі неявно присутній т.з. КОНСТРУКТОР КОПІЮВАННЯ, виглядає він так:
	// щоб зробити копію, треба спочатку зробити копію :))) і тд
	// така сігнатура Array(Array original) { не може бути, тому що якби це дозволив компілятор, то при спробі викликати такий конструктор, була б бескінечна рекурсія
	// якщо не зробити КК явно, то компілятор зробить ось такий метод
	Array(const Array& original) {
		// на відміну від неявного конструктора без параметрів ЗА ЗАМОВЧУВАННЯМ,
		// КК ЗА ЗАМОВЧУВАННЯМ містить певні інструкції (тіло не пусте),
		// що буде: всі поля скопіюються ПОВЕРХНЕВО з орігінала в копію
		// якщо в класі нема полів-покажчиків, то в принципі все буде чудово
		// якщо в класі 2 поля, то буде таке
		this->data = original.data;
		this->length = original.length;
		// якщо полів буде більше, то й інструкцій буде більше
	}
};

int main() {
	SetConsoleOutputCP(1251);
	srand(time(0));

	Array original; // тут автоматично спрацює конструктор без параметрів (явний)
	original.AddToBack(10);
	original.AddToBack(20);
	original.AddToBack(30);
	original.Print(); // 10 20 30

	Array copy = original; // 10 20 30
	// Array copy(original); // створюється об'єкт-копія НА БАЗІ ВЖЕ ІСНУЮЧОГО ОБ'ЄКТА
	// об'єкт не можна створити без конструктора

	// int x = 10;
	// int x(10);

	// якщо в класі є поле-покажчик, то об'єкт цього класу буде тримати в цьому покажчику певну адресу
	// нажаль, стандартна поведінка КК полягає в ПОБІТОВОМУ (по одному біту), або ПОВЕРХНЕМВОМУ копіюванні
	// об'єкт-копія в СВОЄ поле-покажчик ОТРИМАЄ ТУ САМУ АДРЕСУ, що була в оригіналі
	// ПРОБЛЕМА: дані (наприклад, динамічний масив) будуть лише в ЄДИНОМУ ЕКЗЕМПЛЯРІ, а покажчиків на цей контент буде декілька (як мінімум 2)

	// так як присутнє поле-покажчик, і пам'ять під нього виділена, то в КЛАСІ МАЄ БУТИ ДЕСТРУКТОР З ДЕЛІТОМ ! якщо ні - буде виток пам'яті (утечка!)
	// через що відбувається виліт: об'єкта 2, для кожно з них має викликатись деструктор, а в деструкторі йде деліт
	// якщо зробити 2 рази деліт по одній і тій самій адресі - буде виліт! 
}

// ---------------------------------------------------------------------------

// задача: підрахувати загальну кількість об'єктів на локації
//class Enemy {
//	string name;
//	int health;
//	int mana;
//	int armor;
//};
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	int count = 0;
//	Enemy a;
//	count++;
//	Enemy b;
//	count++;
//	cout << count << "\n"; // 2
//	Enemy ar[5];
//	count += 5;
//	cout << count << "\n"; // 7
//	Enemy* ptr = new Enemy[3];
//	count += 3;
//	cout << count << "\n"; // 10
//
//	int day = 2; // tuesday
//	if (day == 2) {
//		Enemy c;
//		count++;
//		cout << count << "\n"; // 11
//		count--;
//	}
//	cout << count << "\n"; // 10 !!!
//}

// ---------------------------------------------------------------------------
// 
// // глобальна змінна (поки що)
//int enemy_count = 0; // вона буде загальною для ВСІХ ОБ'ЄКТІВ незалежно від їх кількості
//
//// задача: підрахувати загальну кількість об'єктів на локації
//class Enemy {
//	string name;
//	int health;
//	int mana;
//	int armor;
//
//public:
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++;
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--;
//	}
//};
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	cout << enemy_count << "\n";
//	Enemy a;
//	Enemy b;
//	cout << enemy_count << "\n"; // 2
//
//	Enemy ar[5];
//	cout << enemy_count << "\n"; // 7
//	Enemy* ptr = new Enemy[3];
//	cout << enemy_count << "\n"; // 10
//
//	int day = 2; // tuesday
//	if (day == 2) {
//		Enemy c;
//		cout << enemy_count << "\n"; // 11
//	}
//	cout << enemy_count << "\n"; // 10 !!!
//
//	delete[] ptr;
//}
// 
// ---------------------------------------------------------------------------

// глобальна змінна (поки що)
//int enemy_count = 0; // вона буде загальною для ВСІХ ОБ'ЄКТІВ незалежно від їх кількості
//
//// задача: підрахувати загальну кількість об'єктів на локації
//class Enemy {
//	string name;
//	int health;
//	int mana;
//	int armor;
//
//public:
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++;
//		if (enemy_count > 10) {
//			throw "ERROR COUNT!\nTOO MANY OBJECTS!\n";
//		}
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--;
//	}
//};
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	Enemy a;
//	Enemy b;
//	Enemy ar[5];
//	Enemy c;
//	Enemy d;
//	Enemy e;
//	// Enemy f; // ERROR !!!
//}

// ---------------------------------------------------------------------------

//Enemy a;
//Enemy b;
//Enemy ar[5];
//Enemy* ptr = new Enemy[3];
//delete[] ptr;
//ptr = new Enemy[2];
//delete[] ptr;
//// Enemy f; // ERROR !!!

// ---------------------------------------------------------------------------

//class Enemy {
//	string name;
//	int health;
//	int mana;
//
//	// ПРОБЛЕМА: звичайні (екземплярні) поля - копіюються на кожен об'єкт при його створенні
//	// бувають ситуації, коли треба розділити дані на всі об'єкти, незалежно від їх кількості
//	// звісно, можна зробити глобальну змінну, але це порушує ООП-підхід
//	// якщо якість дані мають відношення до того чи іншого типу даних, вони мають бути на рівні коду прив'язані до цього типу даних
//	static unsigned int enemy_count; // приклад статичного поля загального користування (всі об'єкти класу скільки б їх не було), будуть "бачити" одне загальне значення
//	// статичні поля не впливають на розмір типу або об'єкту (якщо перевіряти через сайзоф)
//
//	// особливості: якщо статичне поле - це змінна, то її не можна проініціалізувати прямо в класі (=0)
//public:
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++; // 1
//		if (enemy_count > 10) {
//			throw "ERROR COUNT!\nTOO MANY OBJECTS!\n";
//		}
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--; // 0
//	}
//};
//// в С++ статичне поле потрібно ЩЕ РАЗ проголосити ЗА МЕЖАМИ КЛАСУ, і там уже можна надати значення
//// фактично, статичне поле - ЦЕ САМА ЗВИЧАЙНА ГЛОБАЛЬНА ЗМІННА
//// але, завдякі позначці Enemy:: тепер буде сказано чітко в коді, що ця змінна має безпосереднє відношення саме до типу Енемі
//unsigned int Enemy::enemy_count = 0;
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//	Enemy ar[20];
//
//}

// ---------------------------------------------------------------------------

//class Enemy {
//	string name;
//	int health;
//	int mana;
//
//	// ПРОБЛЕМА: звичайні (екземплярні) поля - копіюються на кожен об'єкт при його створенні
//	// бувають ситуації, коли треба розділити дані на всі об'єкти, незалежно від їх кількості
//	// звісно, можна зробити глобальну змінну, але це порушує ООП-підхід
//	// якщо якість дані мають відношення до того чи іншого типу даних, вони мають бути на рівні коду прив'язані до цього типу даних
//public:
//	static unsigned int enemy_count; // приклад статичного поля загального користування (всі об'єкти класу скільки б їх не було), будуть "бачити" одне загальне значення
//	// статичні поля не впливають на розмір типу або об'єкту (якщо перевіряти через сайзоф)
//
//	// особливості: якщо статичне поле - це змінна, то її не можна проініціалізувати прямо в класі (=0)
//public:
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++; // 1
//		if (enemy_count > 10) {
//			throw "ERROR COUNT!\nTOO MANY OBJECTS!\n";
//		}
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--; // 0
//	}
//};
//// в С++ статичне поле потрібно ЩЕ РАЗ проголосити ЗА МЕЖАМИ КЛАСУ, і там уже можна надати значення
//// фактично, статичне поле - ЦЕ САМА ЗВИЧАЙНА ГЛОБАЛЬНА ЗМІННА
//// але, завдякі позначці Enemy:: тепер буде сказано чітко в коді, що ця змінна має безпосереднє відношення саме до типу Енемі
//unsigned int Enemy::enemy_count = 0;
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//	Enemy ar[10];
//	// якщо зробити поле публічним, то звісно до нього можна буде легко звертатися на читання
//	cout << "Count of objects: " << Enemy::enemy_count << "\n";
//	Enemy::enemy_count = -123; // OOPS!!!
//	cout << "Count of objects: " << Enemy::enemy_count << "\n";
//
//}

// ---------------------------------------------------------------------------

//class Enemy {
//	string name;
//	int health;
//	int mana;
//
//	// на практиці у 99% випадків, статичні поля так само як і екземплярні - будуть закриті (в приватній секції та будуть частиною реалізації)
//	static unsigned int enemy_count; // приклад статичного поля загального користування (всі об'єкти класу скільки б їх не було), будуть "бачити" одне загальне значення
//	// в даному випадку, для поля каунт НЕ БУДЕ СЕТТЕРА (логіка інша)
//public:
//	// геттер для статичного поля
//	unsigned int GetCount() const {
//		return enemy_count;
//	}
//
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++; // 1
//		if (enemy_count > 10) {
//			throw "ERROR COUNT!\nTOO MANY OBJECTS!\n";
//		}
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--; // 0
//	}
//};
//
//unsigned int Enemy::enemy_count = 0;
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	// звичайні методи класу викликаються ЧЕРЕЗ НАЗВУ ПЕВОГО ОБ'ЄКТА !!!
//	// 1) якщо об'єктів ще нема взагалі, то кого спитати про кількість???
//	// cout << "Count of objects: " << ????.GetCount() << "\n";
//
//	// 2) якщо об'єктів буде декілька, то як обрати одну з назв?
//	Enemy a;
//	Enemy b;
//	cout << "Count of objects: " << b.GetCount() << "\n";
//
//
//	// проблема: якщо відкрити поле (зробити його публічним), то буде доступ до нього ЯК НА ЧИТАННЯ, ТАК І НА ЗАПИС !!!
//	// це буде порушувати логіку по роботі з полем (+1 в конструкторі, -1 в деструкторі)
//	// іншиз варіантів зміни значення не планується і не має бути
//}

// ---------------------------------------------------------------------------

//class Enemy {
//	string name;
//	int health;
//	int mana;
//
//	// на практиці у 99% випадків, статичні поля так само як і екземплярні - будуть закриті (в приватній секції та будуть частиною реалізації)
//	static unsigned int enemy_count; // приклад статичного поля загального користування (всі об'єкти класу скільки б їх не було), будуть "бачити" одне загальне значення
//	// в даному випадку, для поля каунт НЕ БУДЕ СЕТТЕРА (логіка інша)
//public:
//	// геттер для статичного поля
//	unsigned int GetCount() const {
//		return enemy_count;
//	}
//
//	Enemy() {
//		cout << "C-TOR\n";
//		enemy_count++; // 1
//		if (enemy_count > 10) {
//			throw "ERROR COUNT!\nTOO MANY OBJECTS!\n";
//		}
//	}
//	~Enemy() {
//		cout << "D-TOR\n";
//		enemy_count--; // 0
//	}
//};
//
//unsigned int Enemy::enemy_count = 0;
//
//int main() {
//	SetConsoleOutputCP(1251);
//	srand(time(0));
//
//	// звичайні методи класу викликаються ЧЕРЕЗ НАЗВУ ПЕВОГО ОБ'ЄКТА !!!
//	// 1) якщо об'єктів ще нема взагалі, то кого спитати про кількість???
//	// cout << "Count of objects: " << ????.GetCount() << "\n";
//
//	// 2) якщо об'єктів буде декілька, то як обрати одну з назв?
//	Enemy a;
//	Enemy b;
//	cout << "Count of objects: " << b.GetCount() << "\n";
//
//
//	// проблема: якщо відкрити поле (зробити його публічним), то буде доступ до нього ЯК НА ЧИТАННЯ, ТАК І НА ЗАПИС !!!
//	// це буде порушувати логіку по роботі з полем (+1 в конструкторі, -1 в деструкторі)
//	// іншиз варіантів зміни значення не планується і не має бути
//}

// ---------------------------------------------------------------------------

#include <iostream>
#include <windows.h>
#include <algorithm>
using namespace std;

class Array {
	unsigned int capacity = 10; // при створенні масиву, він одразу для себе робить запас пам'яті на 10 елементів
	int* data = new int[capacity];
	unsigned int length = 0; // фактична (реальна) кількість елементів, присутніх у масиві

public:
	Array() {}

	void AddToBack(int value) {
		if (length < capacity) // якщо виділенної зарання пам'яті ВИСТАЧАЄ для додавання чергового елемента
			data[length] = value;
		else { // АЛЕ ЯКЩО МІСЦЯ ВЖЕ НЕ ВИСТАЧАЄ, ТО
			// треба перевиділити пам'ять
			capacity *= 2; // збільшуємо запас пам'яті у 2 рази (можна і в 1.5, можна і в 1.2)
			// якщо був запас 10 елементів, то стане 20
			// якщо запас був 20 елементів, то стане 40, і тд
			int* temp = new int[capacity]; // новий масив буде в 2 рази більше по пам'яті
			// але в старому масиві все ще усього 10 елементів, тому цикл треба написати так, щоб зачепити лише старі елементі зі старого масиву
			for (int i = 0; i < length; i++) {
				temp[i] = data[i];
			}
			// в новий масив в кінець (по індексу 10) пишеться ОДИНАДЦЯТИЙ елемент
			temp[length] = value;
			delete[] data; // в цілях запобігання витокам пам'яті, чистимо пам'ять від старого масиву
			data = temp; // переставляємо покажчик на новий масив
		}
		length++;
	}

	void AddToFront(int value) {
		if (length < capacity) { // ще є вільна пам'ять під черговий елмент
			// перевиділяти пам'ять на 1 елемент кожен раз - погана ідея (якщо елементів буде більше ніж 300000+ то все буде відбуватися максимально повільно)
			// при тому що пам'ять вже виділена (є кепесіті), то доведеться зробити зсув для всіх існуючих елементів на 1 вправо
			for (int i = length - 1; i >= 0; i--) { // зсув іде справа наліво (тому що якщо робити його зліва направо, з початку масива в кінець) то можна втратити існуючі елементи
				data[i + 1] = data[i];
			}
			data[0] = value;
		}
		else { // АЛЕ ЯКЩО МІСЦЯ ВЖЕ НЕ ВИСТАЧАЄ, ТО
			// треба перевиділити пам'ять
			capacity *= 2; // збільшуємо запас пам'яті у 2 рази (можна і в 1.5, можна і в 1.2)
			// якщо був запас 10 елементів, то стане 20
			// якщо запас був 20 елементів, то стане 40, і тд
			int* temp = new int[capacity]; // новий масив буде в 2 рази більше по пам'яті
			// але в старому масиві все ще усього 10 елементів, тому цикл треба написати так, щоб зачепити лише старі елементі зі старого масиву
			for (int i = 0; i < length; i++) {
				temp[i + 1] = data[i];
			}
			// в новий масив в початок (по індексу 0) пишеться ОДИНАДЦЯТИЙ елемент
			temp[0] = value;
			delete[] data; // в цілях запобігання витокам пам'яті, чистимо пам'ять від старого масиву
			data = temp; // переставляємо покажчик на новий масив
		}
		length++;
	}

	void RemoveFromBack() {
		if (length == 0) {
			cout << "масив пустий, видаляти НЕМА ЧОГО!\n";
			return;
		}
		length--;
	}

	void Print() const {
		if (length == 0) {
			cout << "масив пустий!\n";
		}
		else {
			cout << "елементи масиву: ";
			for (int i = 0; i < length; i++)
			{
				cout << data[i] << " ";
			}
			cout << "\n";
		}
	}

	~Array() {
		cout << "D-TOR\n";
		if (data != nullptr) {
			delete[] data;
		}
	}

	Array(const Array& original) {
		cout << "COPY C-TOR\n";
		this->length = original.length;
		this->capacity = original.capacity;
		this->data = new int[capacity];
		for (int i = 0; i < length; i++)
			this->data[i] = original.data[i];
	}

	void Clear() {
		delete[] data;
		data = nullptr;
		length = 0;
		capacity = 0;
	}

	unsigned int GetLength() const {
		return length;
	}
};

// загальний синтаксис як зробити перевантаження у вигляді глобальної функції

// тип_результату operator значок_операції (параметри) {
	// список дій
// }

void operator +=(Array& a, int value) {
	cout << "HELLO FROM += function !!!\n";
	a.AddToBack(value);
}

// не можна зробити первантаження для вже існуючих операндів
//void operator << (ostream& os, const int& a) {
//	cout << "cout << !!!\n";
//}

ostream& operator << (ostream& cout, const Array& a) {
	// cout << "cout << !!!\n";
	a.Print();
	return cout;
}

void operator >> (istream& cin, Array& a) {
	cout << "cin >> !!!\n";
	// a.Array::~Array(); // явний виклик деструктора
	// a.Clear();
	while (a.GetLength() > 0) {
		a.RemoveFromBack();
	}
	int count;
	cout << "How many elements do you need? ";
	cin >> count; // 5
	for (int i = 0; i < count; i++)
	{
		int value;
		cout << "Please, enter value for element # " << i << ": ";
		cin >> value;
		a.AddToBack(value);
	}
}

int main() {
	SetConsoleOutputCP(1251);
	srand(time(0));

	Array a;
	cin >> a;
	// operator >> (cin, a);

	cout << a;
}

// ---------------------------------------------------------------------------