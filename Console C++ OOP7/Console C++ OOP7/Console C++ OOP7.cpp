// ------------------------------------------------
#include <iostream>
using namespace std;

//class Transport {
//	string description;
//
//public:
//	void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//int main() {
//	Car* c = new Car;
//	Bike* b = new Bike;
//
//	// раннє зв'язування
//	// 
//	// компілятору треба визначити, з якого класа береться реалізація методу
//	// при виклику метода Драйв, компілятор звертає увагу на тип покажчика
//	// якщо покажчик з типом Car, то в першу чергу компілятор іде в клас Кар, і шукає реалізацію методу Драйв там
//	// але може бути ситуація, при якій методу Драйв в класі покажчика нема - наприклад людинка, що успадкувалася від Транспорта, просто забула зробити перевизначення методу, це ок, це значить, що можливо У БАТЬКА є такий метод, і компілятор піде шукати реалізацію від БК
//	// якщо і в батька нема такого методу, то компілятор піде "вище", до батька батька по іерархіі, а там уже як повезе, бо батька батька може і не бути (може бути помилка компіляціі, якщо ніхто не надав реалізацію методу)
//	// на етапі збирання програми, компілятор перевіряє в першу чергу класс покажчика (ТИП ПОКАЖЧИКА для комплілятора - це головне)
//	c->Drive();
//	b->Drive();
//}

//1) в прикладі вище все побудовано на успадкуванні
//2) завдання БК - означити ІНТЕРФЕЙС(загальну поведінку як для себе, так і в першу чергу для НАЩАДКІВ),
// класс транспорт каже, ЩО МОЖНА ІЗДИТИ(не каже ЯК САМЕ, просто сам факт)
//
//3) класи нащадки можуть погодитись з тією реалізацією, яку надає БК по успадкуванню, а можуть і не погодитись,
// і надати свою нову реалізацію
// ------------------------------------------------
//БК - інтерфейс
//
//нащаки - надають реалізацію під цей інтерфейс(будуть деталі)
//
//ОДИН ІНТЕРФЕЙС - БАГАТО РЕАЛІЗАЦІЙ
// 
// ситуація:
//наприклад, треба зробити симуляцію переміщення транспортних засобів по дорозі
//
//проблеми(завдання) :
//	об'єктів типів нащадків має бути багато (з них треба сформувати колекцію - динамічний масив, список тощо)
//	ці об'єкти мають бути різних типів
//	int main() {
//	Car cars[500];
//	Bike bikes[10];

// тут нема гнучкості, при запуску програми буде одна й та сама кількість тих чи інших транспортних засобів
//}
// 
// якщо треба буде ще один транспортний засіб (якогось іншого виду), ТО ТРЕБА ВНОСИТИ ПРАВКИ В КОД
// ------------------------------------------------
//Car cars[500];
//Bike bikes[10];
//Tram trams[5];
//// можливо, будуть потрібрні об'єкти тих типів, що іх навіть іще і нема...
//Trolleybus trs[3];
//// навіть якщо дописати тип Тролейбус в код, то потім цих нащадків може стати набагато більше, штук 50
// ------------------------------------------------
//int main() {
//	// сама велика проблема, що в будь якій колекціі ЕЛЕМЕНТИ ЗАВЖДИ ОДНОТИПНІ !!!!!!
//	// якщо це масив Автівок, то туди ніяк не додатиелемент з типом Мотоцикл!!!
//	Car cars[500];
//	// халепа: для кожного типу транспорту треба запускати ОКРЕМИЙ ЦИКЛ, щоб якось перебрати елементи
//	for (int i = 0; i < 500; i++)
//		cars[i].Drive();
//
//	Bike bikes[10];
//	for (int i = 0; i < 10; i++)
//		bikes[i].Drive();
//
//	Tram trams[5];
//	for (int i = 0; i < 5; i++)
//		trams[i].Drive();
//
//}
// ------------------------------------------------
//Небольшое улучшение
//
//const int cars_count = 500;
//Car cars[cars_count];
//// халепа: для кожного типу транспорту треба запускати ОКРЕМИЙ ЦИКЛ, щоб якось перебрати елементи
//for (int i = 0; i < cars_count; i++)
//	cars[i].Drive();
//
//const int bikes_count = 10;
//Bike bikes[bikes_count];
//for (int i = 0; i < bikes_count; i++)
//	bikes[i].Drive();
//
//const int trams_count = 3;
//Tram trams[trams_count];
//for (int i = 0; i < trams_count; i++)
//	trams[i].Drive();
// 
// якщо буде додано ще один тип елементів нащадків - треба вносити правки в код
// всі ці елементи НЕМОЖЛИВО згуртувати в одну колекцію (тому що типи елементів РІЗНІ)
// для кожноі колекціі ТРЕБА ОКРЕМИЙ ЦИКЛ
 
// а хочеться поменще коду, і так щоб цикл був один
// ------------------------------------------------
// дійсно, зазвичай код буде виглядати якось так:
//Car* ptr = new Car(); // тип об'єкта співпадає з типом покажчика

// але це не допоможе:
// - зробити велику кількість об'єктів різних типів в одній колекціі
// - додавати та видаляти елементи різних типів
// - перебирати всі ці елементи різних типів одним циклом
// ТОМУ ЩО колекціі за визначенням тримають в собі елементи одного типу!
// ------------------------------------------------
//class Transport {
//	string description;
//
//public:
//	void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//	int volume = 100;
//	string model = "Porsche Cayenn";
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//	void Bibik() {
//		cout << volume << " " << model << "\n";
//		cout << "FA FA\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//int main() {
//	// вирішення проблеми:
//	// тип покажчика може відрізнятися від типу об'єкту
//	// об'єкт буде дочірнього типу, а покажчик - батьківського
//	// наприклад, автівку можна сприймати як транспортний засіб
//	Transport* ptr = new Bike();
//	// якщо покажчик буде з типом батьківського класу, то через нього можна буде викликати лише ті методи, ЩО ПРИСУТНІ в класі по типу покажчика (а не дочірнього типу!!)
//	// ptr->Bibik() не працює, поки не додати цей метод в батьківський клас (але скоріш за все такий метод І НЕ ПОТРІБЕН всім нащадкам)
//	// якщо в методі бібік не буде нічого окрім сіаутів (чогось такого, ЩО НЕ ЗАЛЕЖИТЬ від стану об'єкта), то може цей метод і спрацює
//	// але якщо додати роботу зы станом об'єкта в метод, ТО взяти цей стан буде нема в кого
//	((Car*)(ptr))->Bibik();
//	// перетворити тип покажчика-то можна, але якщо не вгадали з справжнім типом об'єкта, то в методі нема буде чого показувати в плані стану, і буде виліт)
//	// щоб робити перетворення ТРЕБА ЗНАТИ справжній тип об'єкта
//	// ще одна проблема: треба робити перевірку типа об'єкта в рантаймі, АЛЕ Й ЦЬОГО РОБИТИ НЕ ХОЧЕТЬСЯ !!!
//
//	cout << "OK!";
//
//
//}
// 
// // тип покажчика може відрізнятися від типу об'єкту
// єдине що, тип покажчика - не будь який, а батьківський (або дідівскьй)
// Transport* p1 = new Car();
// ------------------------------------------------
//class Transport {
//	string description;
//
//public:
//	void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//	int volume = 100;
//	string model = "Porsche Cayenn";
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//	void Bibik() {
//		cout << volume << " " << model << "\n";
//		cout << "FA FA\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//int main() {
//
//	// тип покажчика може відрізнятися від типу об'єкту
//	// єдине що, тип покажчика - не будь який, а батьківський (або дідівскьй)
//	Transport* p1 = new Car();
//	Transport* p2 = new Bike();
//	Transport* p3 = new Tram();
//
//	// раннє зв'язування!!!
//	// компілятор дивиться ТИП ПОКАЖЧИКА !!!
//	// а треба, щоб він брав ту чи іншу реалізацію методу САМЕ ПО ТИПУ ОБ'ЄКТА !!!
//	p1->Drive();
//	p2->Drive();
//	p3->Drive();
//
//
//
// ------------------------------------------------
//class Transport {
//	string description;
//
//public:
//	virtual void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//	int volume = 100;
//	string model = "Porsche Cayenn";
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//	void Bibik() {
//		cout << volume << " " << model << "\n";
//		cout << "FA FA\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//int main() {
//	Transport* p1 = new Car();
//	Transport* p2 = new Bike();
//	Transport* p3 = new Tram();
//
//	// ЯКЩО ТРЕБА підтягувати в рантаймі реалізаціі з класів нащадків (бо об'єкти типів нащадків), то
//	// в батьківському класі треба знайти один чи може і більше методів інтерфейсу (які потім перевизначаються в класах-нащадках), і ВСІ ЦИ МЕТОДИ позначити як virtual
//	// раннє зв'язування зміниться на ПІЗНЕ
//	// ТЕПЕР компілятор буде дивитися на реальний ТИП ОБ'ЄКТА, А НЕ ПОКАЖЧИКА !!!
//	p1->Drive();
//	p2->Drive();
//	p3->Drive();
//}
// ------------------------------------------------
//class Transport {
//	string description;
//
//public:
//	virtual void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//	int volume = 100;
//	string model = "Porsche Cayenn";
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//	void Bibik() {
//		cout << volume << " " << model << "\n";
//		cout << "FA FA\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//class Person {};
//
//int main() {
//	Transport* ptr = nullptr;
//	srand(time(0));
//	rand();
//	// при роботі з випадковими числами комплітор не знає результат функціі ренд зараня
//	// це з'ясується лише в рантаймі, а там уже і комплятора сили нема перевірити значення
//	int r = rand() % 3; // 0 1 2 
//	if (r == 0) ptr = new Car();
//	else if (r == 1) ptr = new Bike();
//	else if (r == 2) ptr = new Tram();
//	ptr->Drive(); // тут не відомо що буде на екрані
//
//	Transport* p1 = new Car();
//	Transport* p2 = new Bike();
//	Transport* p3 = new Tram();
//
//	// ЯКЩО ТРЕБА підтягувати в рантаймі реалізаціі з класів нащадків (бо об'єкти типів нащадків), то
//	// в батьківському класі треба знайти один чи може і більше методів інтерфейсу (які потім перевизначаються в класах-нащадках), і ВСІ ЦИ МЕТОДИ позначити як virtual
//	// раннє зв'язування зміниться на ПІЗНЕ
//	// ТЕПЕР компілятор буде дивитися на реальний ТИП ОБ'ЄКТА, А НЕ ПОКАЖЧИКА !!!
//	p1->Drive();
//	p2->Drive();
//	p3->Drive();
//
//
//}
// ------------------------------------------------
//class Transport {
//	// якщо в класі один або більше методів позначити як вірчуал, то КОМПІЛЯТОР додає в клас автоматично поле отаке
//	// static void** __vfptr = new void*[1]; // VMT
//	// static void** __vfptr[2]; // VMT
//	string description;
//
//public:
//	virtual void Drive() {
//		cout << "Transport::Drive()\n";
//	}
//	virtual void Test() {
//		cout << "Transport::Drive()\n";
//	}
//};
//
//class Car : public Transport {
//	int volume = 100;
//	string model = "Porsche Cayenn";
//	// static void** __vfptr[3]; // VMT
//public:
//	void Drive() {
//		cout << "Car::Drive()\n";
//	}
//	// Test спадкується!!
//	virtual void Bibik() {
//		cout << volume << " " << model << "\n";
//		cout << "FA FA\n";
//	}
//};
//
//class Bike : public Transport {
//public:
//	void Drive() {
//		cout << "Bike::Drive()\n";
//	}
//};
//
//class Tram : public Transport {
//public:
//	void Drive() {
//		cout << "Tram::Drive()\n";
//	}
//};
//
//class Person {};
//
//int main() {
//
//	Transport* ptr = nullptr;
//	srand(time(0));
//	rand();
//	// при роботі з випадковими числами комплітор не знає результат функціі ренд зараня
//	// це з'ясується лише в рантаймі, а там уже і комплятора сили нема перевірити значення
//	int r = rand() % 3; // 0 1 2 
//	if (r == 0) ptr = new Car();
//	else if (r == 1) ptr = new Bike();
//	else if (r == 2) ptr = new Tram();
//	ptr->Drive(); // тут не відомо що буде на екрані
//
//	Transport* p1 = new Car();
//	Transport* p2 = new Bike();
//	Transport* p3 = new Tram();
//
//	// ЯКЩО ТРЕБА підтягувати в рантаймі реалізаціі з класів нащадків (бо об'єкти типів нащадків), то
//	// в батьківському класі треба знайти один чи може і більше методів інтерфейсу (які потім перевизначаються в класах-нащадках), і ВСІ ЦИ МЕТОДИ позначити як virtual
//	// раннє зв'язування зміниться на ПІЗНЕ
//	// ТЕПЕР компілятор буде дивитися на реальний ТИП ОБ'ЄКТА, А НЕ ПОКАЖЧИКА !!!
//	p1->Drive();
//	p2->Drive();
//	p3->Drive();
//
//	// яка саме реалізація підтягнеться, це буде вирішено вже на етапі виконання програми (в рантаймі!) і компілятор до цього вже відношення не має!
//	// сама програма визначає, метод з якого саме класу обрати теж не просто так,
//	// для кожно класа (і для батька, і для дітей) формується ПО ОДНІЙ т.зв. ТАБЛИЦІ ВІРТУАЛЬНИХ МЕТОДІВ (virtual methods table)
//	// фактично, ТВМ - це просто одновимірний масив адрес усіх методів, що позначені як вірчуал
//}

//Transport* ar[3];
//
//ar[0] = new Car();
//ar[1] = new Bike();
//ar[2] = new Tram();
//
//ar[0]->Drive();
//ar[1]->Drive();
//ar[2]->Drive();
// ------------------------------------------------
//Transport* ar[3];
//
//ar[0] = new Car();
//ar[1] = new Bike();
//ar[2] = new Car();
//
//for (int i = 0; i < 3; i++)
//	ar[i]->Drive(); // поліморфний рядок коду !
// ------------------------------------------------

//ДЛЯ ДЗ ПОЛЕЗНО
//
class Transport {
	// якщо в класі один або більше методів позначити як вірчуал, то КОМПІЛЯТОР додає в клас автоматично поле отаке
	// static void** __vfptr = new void*[1]; // VMT
	// static void** __vfptr[2]; // VMT
	string description;

public:
	virtual void Drive() {
		cout << "Transport::Drive()\n";
	}
	virtual void Test() {
		cout << "Transport::Drive()\n";
	}
};

class Car : public Transport {
	int volume = 100;
	string model = "Porsche Cayenn";
	// static void** __vfptr[3]; // VMT
public:
	void Drive() {
		cout << "Car::Drive()\n";
	}
	// Test спадкується!!
	virtual void Bibik() {
		cout << volume << " " << model << "\n";
		cout << "FA FA\n";
	}
};

class Bike : public Transport {
public:
	void Drive() {
		cout << "Bike::Drive()\n";
	}
};

class Tram : public Transport {
public:
	void Drive() {
		cout << "Tram::Drive()\n";
	}
};

class Person {};

int main() {

	srand(time(0));

	int count;
	cout << "How many elements: ";
	cin >> count;

	// Transport* ar = new Transport[3];
	Transport** ar = new Transport * [count];

	for (int i = 0; i < count; i++)
	{
		int r = rand() % 3;
		if (r == 0) ar[i] = new Car();
		if (r == 1) ar[i] = new Bike();
		if (r == 2) ar[i] = new Tram();
	}

	for (int i = 0; i < count; i++)
		ar[i]->Drive(); // поліморфний рядок коду !
}