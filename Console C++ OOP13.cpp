#include <iostream>
#include <fstream>
#include <vector>
#include <string>
using namespace std;
/////////////////////////////////////////////////
// Базовый класс Record
// Абстрактный класс для любой записи(контакт, электронная почта и т.д.)
// Имеет чисто виртуальные методы для реализации полиморфизма
/////////////////////////////////////////////////
class Record {
public:
    virtual void print() = 0;            // делаю метод для вывода на экран
	virtual void saveToFile(ofstream& f) = 0; // потом метод для сохранения в файл, f это ссылка на объект файла   
    virtual ~Record() {}                 // и виртуальный деструктор (всегда нужен при полиморфизме)
};
/////////////////////////////////////////////////
// КЛАСС CONTACT (наследуется от Record, от отца, от базового класса)
/////////////////////////////////////////////////
class Contact : public Record {
private:
    string name;   // это имя контакта
    string phone;  // это контактный телефон
public:
    // делаю сначало конструктор без параметров
    Contact() {
		this->name = ""; // this указатель на объект класса Contact в самом контексте метода класса
		this->phone = ""; // this->name это то же самое, что и name но уже для phone
    }

    // а теперб конструктор з параметрами
    Contact(string name, string phone) { // 
		this->name = name; // this->name это поле класса, а name это параметр конструктора
		this->phone = phone; // this->phone все также поле класса и phone параметр конструктора
    }

    // дальше деструктор
    ~Contact() {
		// ничего тут не делаю так как нету динамической памяти
    }

    // методы доступа (гэтеры)
    string getName() { 
		return name; // возвращаю поле name нашего класса Contact
    }
    string getPhone() {
		return phone; // также возвращаю но уже поле phone
    }

    // методы изменения (сетеры)
	void setName(string name) { // создаю войдовскую функцию setName и принимаю параметр name
		this->name = name;  // this \то указатель на объект а this->name это поле класса Contact
    }
	void setPhone(string phone) { // также создаю войдовскую функцию с приминеным параметром phone
		this->phone = phone; // ну и this->phone поле класса Contact с указателем this
    }

    // тут полиморфный метод печати
	void print() override { // override указывает что я переопределяю метод базового класса Record
		cout << name << " - " << phone << "\n"; // ну и вывод на экран само собой
    }

    // Полиморфный метод сохранения в файл
	void saveToFile(ofstream& f) override { // ofstream& это ссылка на объект файла, а f это короткое имя параметра ну и переопределяю оверайдом
		f << name << " " << phone << "\n"; // f это файл, а name и phone это поля класса Contact
    }
};

/////////////////////////////////////////////////

template <class T> // тут уже просто простой шаблонній контэйнер, типо как свой вектор
class MyArray { // шаблонный класс MyArray
private:
	T* arr;      // указатель на массив типа T
	int size;    // текущий размер массива, количество элементов 
public:
    // конструктор
    MyArray() {
		arr = nullptr; // изначально делаю указатель нулевым 
		size = 0; // и назначаю размеру 0
    }

	// и деструктор
    ~MyArray() {
		delete[] arr; // удаляю массив, если он был вдруг создан, чтобы не было утечки памяти 
    }

	// добавляю элемент в массив
	void add(T item) { // item это параметр типа T который я хочу добавить
		// создаю новый массив тут же и делаю на один элемент больше
		T* newArr = new T[size + 1]; // выделяю память под новый массив

		// копирую старые элементы в новый массив
        for (int i = 0; i < size; i++) {
			newArr[i] = arr[i]; // копирую каждый элемент из старого массива в новый
        }

		// добавляю уже новый элемент в конец нового моего массива
        newArr[size] = item;

		// удаляю старый массив чтобі не дай бог не было утечки памяти
        delete[] arr;

		// переназначаю, переподключаю указатель уже на новый массив
        arr = newArr;

		// в конце концов увеличиваю размер на 1
        size++;
    }

	// принимаю индекс и возвращаю элемент по этому же индексу
	T get(int index) { // index это параметр индекса типа инт, а возвращаю я тип T, то есть элемент массива, который хранится по этому индексу
		// простой проверочный if на выход за границы массива
		if (index >= 0 && index < size) {
			return arr[index]; // возвращаю элемент массива по этому индексу
        }
		else { // если вдруг вышли за границы массива
            cout << "Помилка: вихід за межі масиву!" << "\n";
			return T(); // возвращаю значение по умолчанию для типа T
        }
    }

	// возвращаю текущий размер массива, количество элементов
    int getSize() {
        return size;
    }
};

/////////////////////////////////////////////////
// КЛАСС ContactBook (телефонная книга уже)
/////////////////////////////////////////////////

class ContactBook {
private:
	MyArray<Record*> contacts; // делаю массив указателей на базовый класс Record (полиморфизм), в котором будут храниться все контакты
public:
	// добавляю контакт, принимаю указатель на Record, так как Contact наследуется от Record
	void addContact(Record* r) { // r это указатель на Record
		contacts.add(r); // добавляю этот указатель в массив contacts, который хранит указатели на Record
    }

	// показываю все контакты, использую полиморфизм
    void showAll() {
		if (contacts.getSize() == 0) { // если размер массива 0, то есть нету контактов, то говорю что список пустой
            cout << "Список порожній!" << "\n";
			return; // и выхожу из функции, так как показывать нечего
        }

		// иначе прохожусь по всем контактам и вызываю метод print (полиморфизм)
		for (int i = 0; i < contacts.getSize(); i++) { // прохожусь по всем контактам, от 0 до размера массива
            cout << i + 1 << ". ";
			contacts.get(i)->print(); // вызываю (полиморфный)метод print у каждого контакта, get(i) возвращает указатель на Record
        }
    }

	// сохраняю контакты в файл
	void save(string filename) { // принимаю имя файла в который хочу сохранить, filename это параметр типа string
		ofstream file(filename); // открываю файл с именем filename, если файла нету, он создается 

		// каждый контакт знает как сам себя сохранить в файл (полиморфизм) и прохожусь по всем контактам
        for (int i = 0; i < contacts.getSize(); i++) {
			contacts.get(i)->saveToFile(file); // вызываю (полиморфный)метод saveToFile у каждого контакта
        }

		file.close(); // закрываю файл, чтобы сохранить изменения
    }

	// загружаю контакты из файла, предполагая что файл существует и формат правильный
    void load(string filename) {
		ifstream file(filename); // открываю файл для чтения, если файла нету, будет ошибка
		string name, phone; // создаю переменные типа string для хранения имени и телефона, которые буду читать из файла

		while (file >> name >> phone) { // делаю цикл while пока могу читать из файла имя и телефон, пока не достигну конца файла
			// для каждого прочитанного мною имени и телефона я создаю новый контакт и добавляю его в книгу
			Record* r = new Contact(name, phone); // создаю новый контакт сейчас, name и phone это прочитанные из файла значения
			contacts.add(r); // добавляю этот контакт в массив contacts
        }

		file.close(); // само собой закрываю файл
    }
};

// ГЛАВНАЯ ПРОГРРАММА МЕЙН 

int main() {
	setlocale(0, ""); // чтобы консоль отображала украинские символы
	ContactBook book;  // уже создаю объект книги контактов
	int choice; // переменная для выбора уже в пункте меню
	string filename = "contacts.txt"; // даю имя файлу для сохранения и загрузки контактов

    do {
		// Само меню
        cout << "\nМеню:\n";
        cout << "1. Додати контакт\n";
        cout << "2. Показати всі контакти\n";
        cout << "3. Зберегти у файл\n";
        cout << "4. Завантажити з файлу\n";
        cout << "5. Вихід\n";
        cout << "Ваш вибір: ";
        cin >> choice;
		cin.ignore(); //  очищаю буфер ввода

        if (choice == 1) {
            string name, phone;
            cout << "Введіть ім'я: ";
			getline(cin, name); // использую getline чтобы можно было вводить имена с пробелами, 
            cout << "Введіть телефон: ";
			getline(cin, phone); // также использую getline для телефона

			// создаю новый контакт и добавляю его в книгу используя конечна полиморфизм
            Record* c = new Contact(name, phone);
			book.addContact(c); // добавляю контакт в книгу, c это новый указатель на Record, который на самом деле указывает на Contact

            cout << "Контакт додано!" << "\n";
        }
        else if (choice == 2) {
			book.showAll(); // показываю все контакты
        }
        else if (choice == 3) {
			book.save(filename); // сохраняю контакты в файл
            cout << "Збережено у файл!" << "\n";
        }
        else if (choice == 4) {
			book.load(filename); // загружаю контакты из файла
            cout << "Завантажено з файлу!" << "\n";
        }
		else if (choice == 5) { // выход из программы
            cout << "Вихід..." << "\n";
        }
		else { // если ввели что-то не то
            cout << "Невірний вибір!" << "\n";
        }

    } while (choice != 5);
}